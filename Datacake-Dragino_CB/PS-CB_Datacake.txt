function Decoder(payload, payloadB64) {
    function bytesToHex(bytes) {
        var hex = '';
        for (var i = 0; i < bytes.length; i++) {
            var current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];
            var hexByte = current.toString(16);
            hex += hexByte.length === 1 ? '0' + hexByte : hexByte;
        }
        return hex;
    }
    
    // 修复1: 正确解析32位有符号坐标（处理正负号）
    function parseCoordinate(hex) {
        var value = parseInt(hex, 16);
        if (value > 0x7FFFFFFF) 
            value = value - 0x100000000; // 处理32位有符号整数的补码
        return value / 1000000; // 转换为度
    }

    // 修复2: 版本号格式化为X.XX浮点数
    function parseVersion(hex) {
        var versionInt = parseInt(hex, 16) || 0;
        return (versionInt / 100).toFixed(2); // 例如 506f → 206.15
    }
    
    function parsePayload(hex) {
        var offset = 0;
        function toInt(hexString, lengthInBits) {
            var value = parseInt(hexString, 16);
            if(lengthInBits && (value & (1 << (lengthInBits - 1)))) {
                value -= (1 << lengthInBits);  // two's complement conversion
            }
            return value;
        }

        var deviceID = hex.substr(offset, 16); offset += 16;
        var MSI = hex.substr(offset, 16); offset += 16;
        var versionStr = hex.substr(offset, 4); offset += 4;
        var version = toInt(versionStr) / 100;
        var battery = toInt(hex.substr(offset, 4)) / 1000; offset += 4;
        var signal = toInt(hex.substr(offset, 2)); offset += 2;
        var IN1 = toInt(hex.substr(offset, 2)); offset += 2;
        var IN2 = toInt(hex.substr(offset, 2)); offset += 2;
        var GPIO_EXIT_Level = toInt(hex.substr(offset, 2)); offset += 2;
        var GPIO_EXIT_Flag = toInt(hex.substr(offset, 2)); offset += 2;
        var IDC_alarm = toInt(hex.substr(offset, 2)); offset += 2;
        var VDC_alarm = toInt(hex.substr(offset, 2)); offset += 2;
        var Probe_mod = toInt(hex.substr(offset, 4)); offset += 4;
        var Latitude = parseCoordinate(hex.substr(offset, 8)); offset += 8; // 使用修复的坐标解析
        var Longitude = parseCoordinate(hex.substr(offset, 8)); offset += 8;
        var gps_timestamp = toInt(hex.substr(offset, 8)); offset += 8;
        var IDC_input = toInt(hex.substr(offset, 4))/1000; offset += 4;
        var VDC_input = toInt(hex.substr(offset, 4))/1000; offset += 4;
        var timestamp = toInt(hex.substr(offset, 8)); offset += 8;
        try {
            
            // Parse the higher byte for sensor model
            var sensorModelHex = versionStr.substr(0, 2);
            var sensorModel = parseInt(sensorModelHex, 16);
            
            // Parse the lower byte for software version
            var versionHex = versionStr.substr(2, 2);
            var versionInt = parseInt(versionHex, 16);
            
            // Convert versionInt to version string
            var versionStr = (Math.floor(versionInt / 100)) + '.' + 
                             (Math.floor((versionInt % 100) / 10)) + '.' + 
                             (versionInt % 10);
                             
            console.log('Sensor Model: ' + sensorModel)
            console.log('Version: ' + versionStr)
            
        } catch(e) {
            console.log("Error parsing version")
            console.log(JSON.stringify(e))
        }
        
        var dataSet = [];
        while (offset < hex.length) {
            var IDC_input1 = toInt(hex.substr(offset, 4))/1000; offset += 4;
            var VDC_input1 = toInt(hex.substr(offset, 4))/1000; offset += 4;
            var timestampLog = toInt(hex.substr(offset, 8)); offset += 8;
            dataSet.push({ IDC_input1: IDC_input1, VDC_input1: VDC_input1,timestamp: timestampLog });
        }

        return {
            deviceID: deviceID,
            version: version,
            battery: battery,
            signal: signal,
            IN1: IN1,   
            IN2: IN2,
            GPIO_EXIT_Level: GPIO_EXIT_Level,
            GPIO_EXIT_Flag: GPIO_EXIT_Flag,
            IDC_alarm: IDC_alarm,
            VDC_alarm: VDC_alarm,   
            Probe_mod: Probe_mod,
            IDC_input: IDC_input,
            IDC_input1: IDC_input1,
            VDC_input: VDC_input,
            VDC_input1: VDC_input1,
            Latitude: Latitude,
            Longitude: Longitude,
            timestamp: timestamp,
            gps_timestamp: gps_timestamp,
            dataSet: dataSet,
        };
    }

    var payloadHex = bytesToHex(payloadB64);
    var parsedData = parsePayload(payloadHex);
    payload = parsedData
    var deviceID = payload.deviceID;
    var mainIMSI = payload.IMSI;
    var mainBattery = payload.battery;
    var mainSignal = payload.signal;
    var mainIN1 = payload.IN1;
    var mainIN2 = payload.IN2;
    var mainGPIO_EXIT_Level = payload.GPIO_EXIT_Level;
    var mainGPIO_EXIT_Flag = payload.GPIO_EXIT_Flag;
    var mainIDC_alarm = payload.IDC_alarm;
    var mainVDC_alarm = payload.VDC_alarm;
    var mainProbe_mod = payload.Probe_mod;
    var mainIDC_input = payload.IDC_input;
    var mainVDC_input = payload.VDC_input;
    var mainLatitude  = payload.Latitude;
    var mainLongitude  = payload.Longitude;
    var maingps_timestamp  = payload.gps_timestamp;
    var mainTimestamp = payload.timestamp;
    var result = [];
    var mod = payload.mod;

   result.push({
        field: "BATTERY",
        value: mainBattery,
        timestamp: mainTimestamp
    });
    result.push({
        field: "SIGNAL",
        value: mainSignal,
        timestamp: mainTimestamp
    });
    result.push({
        field: "IN1",
        value: mainIN1,
        timestamp: mainTimestamp
    });
    result.push({
        field: "IN2",
        value: mainIN2,
        timestamp: mainTimestamp
    });
    result.push({
        field: "GPIO_EXIT_Level",
        value: mainGPIO_EXIT_Level,
        timestamp: mainTimestamp
    });
    result.push({
        field: "GPIO_EXIT_Flag",
        value: mainGPIO_EXIT_Flag,
        timestamp: mainTimestamp
    });
        result.push({
        field: "IDC_alarm",
        value: mainIDC_alarm,
        timestamp: mainTimestamp
    });
    result.push({
        field: "VDC_alarm",
        value: mainVDC_alarm,
        timestamp: mainTimestamp
    });
    result.push({
        field: "Probe_mod",
        value: mainProbe_mod,
        timestamp: mainTimestamp
    });
    result.push({
        field: "IDC_input",
        value: mainIDC_input,
        timestamp: mainTimestamp
    });
     result.push({
        field: "VDC_input",
        value: mainVDC_input,
        timestamp: mainTimestamp
    });
    result.push({
        field: "Latitude",
        value: mainLatitude,
        timestamp: mainTimestamp
    });
    result.push({
        field: "Longitude",
        value: mainLongitude,
        timestamp: mainTimestamp
    });
    result.push({
        field: "gps_timestamp",
        value: maingps_timestamp,
        timestamp: mainTimestamp
    });
  
     var dataSet = payload.dataSet;
    for (var i = 0; i < dataSet.length; i++) {
        var data = dataSet[i];
        var IDC_input1 = data.IDC_input1;
        var VDC_input1 = data.VDC_input1;
        var timestamp = data.timestamp;
        
        result.push({
            field: "IDC_input",
            value: IDC_input1,
            timestamp: timestamp
        });
        result.push({
            field: "VDC_input",
            value: VDC_input1,
            timestamp: timestamp
        });
    }
    return result;
}